use core;
use libc;
pub type __uint8_t = libc::c_uchar;
pub type __uint16_t = libc::c_ushort;
pub type __uint32_t = libc::c_uint;
pub type uint8_t = __uint8_t;
pub type uint16_t = __uint16_t;
pub type uint32_t = __uint32_t;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct SCB_Type {
    pub CPUID: uint32_t,
    pub ICSR: uint32_t,
    pub VTOR: uint32_t,
    pub AIRCR: uint32_t,
    pub SCR: uint32_t,
    pub CCR: uint32_t,
    pub SHP: [uint8_t; 12],
    pub SHCSR: uint32_t,
    pub CFSR: uint32_t,
    pub HFSR: uint32_t,
    pub DFSR: uint32_t,
    pub MMFAR: uint32_t,
    pub BFAR: uint32_t,
    pub AFSR: uint32_t,
    pub PFR: [uint32_t; 2],
    pub DFR: uint32_t,
    pub ADR: uint32_t,
    pub MMFR: [uint32_t; 4],
    pub ISAR: [uint32_t; 5],
    pub RESERVED0: [uint32_t; 5],
    pub CPACR: uint32_t,
}
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct RCC_TypeDef {
    pub CR: uint32_t,
    pub CFGR: uint32_t,
    pub CIR: uint32_t,
    pub APB2RSTR: uint32_t,
    pub APB1RSTR: uint32_t,
    pub AHBENR: uint32_t,
    pub APB2ENR: uint32_t,
    pub APB1ENR: uint32_t,
    pub BDCR: uint32_t,
    pub CSR: uint32_t,
    pub AHBRSTR: uint32_t,
    pub CFGR2: uint32_t,
    pub CFGR3: uint32_t,
}
pub type C2RustUnnamed = libc::c_uint;
pub const SET: C2RustUnnamed = 1;
pub const RESET: C2RustUnnamed = 0;
#[derive ( Copy, Clone )]
#[repr(C)]
pub struct FLASH_TypeDef {
    pub ACR: uint32_t,
    pub KEYR: uint32_t,
    pub OPTKEYR: uint32_t,
    pub SR: uint32_t,
    pub CR: uint32_t,
    pub AR: uint32_t,
    pub RESERVED: uint32_t,
    pub OBR: uint32_t,
    pub WRPR: uint32_t,
}
/* *
  ******************************************************************************
  * @file    system_stm32f30x.c
  * @author  MCD Application Team
  * @version V1.1.1
  * @date    28-March-2014
  * @brief   CMSIS Cortex-M4 Device Peripheral Access Layer System Source File.
  *          This file contains the system clock configuration for STM32F30x devices,
  *          and is generated by the clock configuration tool
  *          stm32f30x_Clock_Configuration_V1.0.0.xls
  *
  * 1.  This file provides two functions and one global variable to be called from
  *     user application:
  *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
  *                      and Divider factors, AHB/APBx prescalers and Flash settings),
  *                      depending on the configuration made in the clock xls tool.
  *                      This function is called at startup just after reset and
  *                      before branch to main program. This call is made inside
  *                      the "startup_stm32f30x.s" file.
  *
  *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
  *                                  by the user application to setup the SysTick
  *                                  timer or configure other parameters.
  *
  *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
  *                                 be called whenever the core clock is changed
  *                                 during program execution.
  *
  * 2. After each device reset the HSI (8 MHz) is used as system clock source.
  *    Then SystemInit() function is called, in "startup_stm32f30x.s" file, to
  *    configure the system clock before to branch to main program.
  *
  * 3. If the system clock source selected by user fails to startup, the SystemInit()
  *    function will do nothing and HSI still used as system clock source. User can
  *    add some code to deal with this issue inside the SetSysClock() function.
  *
  * 4. The default value of HSE crystal is set to 8MHz, refer to "HSE_VALUE" define
  *    in "stm32f30x.h" file. When HSE is used as system clock source, directly or
  *    through PLL, and you are using different crystal you have to adapt the HSE
  *    value to your own configuration.
  *
  * 5. This file configures the system clock as follows:
  *=============================================================================
  *                         Supported STM32F30x device
  *-----------------------------------------------------------------------------
  *        System Clock source                    | PLL (HSE)
  *-----------------------------------------------------------------------------
  *        SYSCLK(Hz)                             | 72000000
  *-----------------------------------------------------------------------------
  *        HCLK(Hz)                               | 72000000
  *-----------------------------------------------------------------------------
  *        AHB Prescaler                          | 1
  *-----------------------------------------------------------------------------
  *        APB2 Prescaler                         | 2
  *-----------------------------------------------------------------------------
  *        APB1 Prescaler                         | 2
  *-----------------------------------------------------------------------------
  *        HSE Frequency(Hz)                      | 8000000
  *----------------------------------------------------------------------------
  *        PLLMUL                                 | 9
  *-----------------------------------------------------------------------------
  *        PREDIV                                 | 1
  *-----------------------------------------------------------------------------
  *        USB Clock                              | ENABLE
  *-----------------------------------------------------------------------------
  *        Flash Latency(WS)                      | 2
  *-----------------------------------------------------------------------------
  *        Prefetch Buffer                        | ON
  *-----------------------------------------------------------------------------
  *=============================================================================
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */
/* * @addtogroup CMSIS
  * @{
  */
/* * @addtogroup stm32f30x_system
  * @{
  */
/* * @addtogroup STM32F30x_System_Private_Includes
  * @{
  */
#[no_mangle]
pub static mut hse_value: uint32_t = 8000000i32 as uint32_t;
/* !< Vector Table base offset field.
                                  This value must be a multiple of 0x200. */
/* *
  * @}
  */
/* Private macro -------------------------------------------------------------*/
/* * @addtogroup STM32F30x_System_Private_Variables
  * @{
  */
#[no_mangle]
pub static mut SystemCoreClock: uint32_t = 72000000i32 as uint32_t;
#[no_mangle]
pub static mut AHBPrescTable: [uint8_t; 16] =
    [0i32 as uint8_t, 0i32 as uint8_t, 0i32 as uint8_t, 0i32 as uint8_t,
     0i32 as uint8_t, 0i32 as uint8_t, 0i32 as uint8_t, 0i32 as uint8_t,
     1i32 as uint8_t, 2i32 as uint8_t, 3i32 as uint8_t, 4i32 as uint8_t,
     6i32 as uint8_t, 7i32 as uint8_t, 8i32 as uint8_t, 9i32 as uint8_t];
/* *
  * @}
  */
/* * @addtogroup STM32F30x_System_Private_Functions
  * @{
  */
/* *
  * @brief  Setup the microcontroller system
  *         Initialize the Embedded Flash Interface, the PLL and update the
  *         SystemFrequency variable.
  * @param  None
  * @retval None
  */
#[no_mangle]
pub unsafe extern "C" fn SystemInit() {
    /* FPU settings ------------------------------------------------------------*/
    /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
    let ref mut fresh0 =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CR;
    ::core::ptr::write_volatile(fresh0,
                                (::core::ptr::read_volatile::<uint32_t>(fresh0
                                                                            as
                                                                            *const uint32_t)
                                     as libc::c_uint | 0x1i32 as uint32_t) as
                                    uint32_t as uint32_t);
    /* Reset CFGR register */
    let ref mut fresh1 =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CFGR;
    ::core::ptr::write_volatile(fresh1,
                                (::core::ptr::read_volatile::<uint32_t>(fresh1
                                                                            as
                                                                            *const uint32_t)
                                     as libc::c_uint & 0xf87fc00cu32) as
                                    uint32_t as uint32_t);
    /* Reset HSEON, CSSON and PLLON bits */
    let ref mut fresh2 =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CR;
    ::core::ptr::write_volatile(fresh2,
                                (::core::ptr::read_volatile::<uint32_t>(fresh2
                                                                            as
                                                                            *const uint32_t)
                                     as libc::c_uint & 0xfef6ffffu32) as
                                    uint32_t as uint32_t);
    /* Reset HSEBYP bit */
    let ref mut fresh3 =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CR;
    ::core::ptr::write_volatile(fresh3,
                                (::core::ptr::read_volatile::<uint32_t>(fresh3
                                                                            as
                                                                            *const uint32_t)
                                     as libc::c_uint & 0xfffbffffu32) as
                                    uint32_t as uint32_t);
    /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
    let ref mut fresh4 =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CFGR;
    ::core::ptr::write_volatile(fresh4,
                                (::core::ptr::read_volatile::<uint32_t>(fresh4
                                                                            as
                                                                            *const uint32_t)
                                     as libc::c_uint & 0xff80ffffu32) as
                                    uint32_t as uint32_t);
    /* Reset PREDIV1[3:0] bits */
    let ref mut fresh5 =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CFGR2;
    ::core::ptr::write_volatile(fresh5,
                                (::core::ptr::read_volatile::<uint32_t>(fresh5
                                                                            as
                                                                            *const uint32_t)
                                     as libc::c_uint & 0xfffffff0u32) as
                                    uint32_t as uint32_t);
    /* Reset USARTSW[1:0], I2CSW and TIMs bits */
    let ref mut fresh6 =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CFGR3;
    ::core::ptr::write_volatile(fresh6,
                                (::core::ptr::read_volatile::<uint32_t>(fresh6
                                                                            as
                                                                            *const uint32_t)
                                     as libc::c_uint & 0xff00fcccu32) as
                                    uint32_t as uint32_t);
    /* Disable all interrupts */
    ::core::ptr::write_volatile(&mut (*((0x40000000i32 as
                                             uint32_t).wrapping_add(0x20000i32
                                                                        as
                                                                        libc::c_uint).wrapping_add(0x1000i32
                                                                                                       as
                                                                                                       libc::c_uint)
                                            as *mut RCC_TypeDef)).CIR as
                                    *mut uint32_t, 0i32 as uint32_t);
    /* Configure the System clock source, PLL Multiplier and Divider factors,
     AHB/APBx prescalers and Flash settings ----------------------------------*/
  //SetSysClock(); // called from main()
    ::core::ptr::write_volatile(&mut (*(0xe000e000u64.wrapping_add(0xd00u64)
                                            as *mut SCB_Type)).VTOR as
                                    *mut uint32_t,
                                0x8000000i32 as uint32_t |
                                    0i32 as libc::c_uint);
    /* Vector Table Relocation in Internal FLASH. */
}
/* *
  ******************************************************************************
  * @file    system_stm32f30x.h
  * @author  MCD Application Team
  * @version V1.1.1
  * @date    28-March-2014
  * @brief   CMSIS Cortex-M4 Device System Source File for STM32F30x devices.
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  *
  * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  * You may not use this file except in compliance with the License.
  * You may obtain a copy of the License at:
  *
  *        http://www.st.com/software_license_agreement_liberty_v2
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
  ******************************************************************************
  */
/* * @addtogroup CMSIS
  * @{
  */
/* * @addtogroup stm32f30x_system
  * @{
  */
/* *
  * @brief Define to prevent recursive inclusion
  */
/* Exported types ------------------------------------------------------------*/
/* !< System Clock Frequency (Core Clock) */
/* Exported constants --------------------------------------------------------*/
/* Exported macro ------------------------------------------------------------*/
/* Exported functions ------------------------------------------------------- */
/* * @addtogroup STM32F30x_System_Exported_Functions
  * @{
  */
/* *
   * @brief  Update SystemCoreClock variable according to Clock Register Values.
  *         The SystemCoreClock variable contains the core clock (HCLK), it can
  *         be used by the user application to setup the SysTick timer or configure
  *         other parameters.
  *
  * @note   Each time the core clock (HCLK) changes, this function must be called
  *         to update SystemCoreClock variable value. Otherwise, any configuration
  *         based on this variable will be incorrect.
  *
  * @note   - The system frequency computed by this function is not the real
  *           frequency in the chip. It is calculated based on the predefined
  *           constant and the selected clock source:
  *
  *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
  *
  *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
  *
  *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**)
  *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
  *
  *         (*) HSI_VALUE is a constant defined in stm32f30x.h file (default value
  *             8 MHz) but the real value may vary depending on the variations
  *             in voltage and temperature.
  *
  *         (**) HSE_VALUE is a constant defined in stm32f30x.h file (default value
  *              8 MHz), user has to ensure that HSE_VALUE is same as the real
  *              frequency of the crystal used. Otherwise, this function may
  *              have wrong result.
  *
  *         - The result of this function could be not correct when using fractional
  *           value for HSE crystal.
  *
  * @param  None
  * @retval None
  */
#[no_mangle]
pub unsafe extern "C" fn SystemCoreClockUpdate() {
    let mut tmp: uint32_t = 0i32 as uint32_t;
    let mut pllmull: uint32_t = 0i32 as uint32_t;
    let mut pllsource: uint32_t = 0i32 as uint32_t;
    let mut prediv1factor: uint32_t = 0i32 as uint32_t;
    /* Get SYSCLK source -------------------------------------------------------*/
    tmp =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CFGR & 0xci32 as uint32_t;
    match tmp {
        0 => {
            /* HSI used as system clock */
            SystemCoreClock = 8000000i32 as uint32_t
        }
        4 => {
            /* HSE used as system clock */
            SystemCoreClock = 8000000i32 as uint32_t
        }
        8 => {
            /* PLL used as system clock */
            /* Get PLL clock source and multiplication factor ----------------------*/
            pllmull =
                (*((0x40000000i32 as
                        uint32_t).wrapping_add(0x20000i32 as
                                                   libc::c_uint).wrapping_add(0x1000i32
                                                                                  as
                                                                                  libc::c_uint)
                       as *mut RCC_TypeDef)).CFGR & 0x3c0000i32 as uint32_t;
            pllsource =
                (*((0x40000000i32 as
                        uint32_t).wrapping_add(0x20000i32 as
                                                   libc::c_uint).wrapping_add(0x1000i32
                                                                                  as
                                                                                  libc::c_uint)
                       as *mut RCC_TypeDef)).CFGR & 0x10000i32 as uint32_t;
            pllmull = (pllmull >> 18i32).wrapping_add(2i32 as libc::c_uint);
            if pllsource == 0i32 as libc::c_uint {
                /* HSI oscillator clock divided by 2 selected as PLL clock entry */
                SystemCoreClock =
                    (8000000i32 as uint32_t >> 1i32).wrapping_mul(pllmull)
            } else {
                prediv1factor =
                    ((*((0x40000000i32 as
                             uint32_t).wrapping_add(0x20000i32 as
                                                        libc::c_uint).wrapping_add(0x1000i32
                                                                                       as
                                                                                       libc::c_uint)
                            as *mut RCC_TypeDef)).CFGR2 &
                         0xfi32 as
                             uint32_t).wrapping_add(1i32 as libc::c_uint);
                /* HSE oscillator clock selected as PREDIV1 clock entry */
                SystemCoreClock =
                    (8000000i32 as
                         libc::c_uint).wrapping_div(prediv1factor).wrapping_mul(pllmull)
            }
        }
        _ => {
            /* HSI used as system clock */
            SystemCoreClock = 8000000i32 as uint32_t
        }
    }
    /* Compute HCLK clock frequency ----------------*/
  /* Get HCLK prescaler */
    tmp =
        AHBPrescTable[(((*((0x40000000i32 as
                                uint32_t).wrapping_add(0x20000i32 as
                                                           libc::c_uint).wrapping_add(0x1000i32
                                                                                          as
                                                                                          libc::c_uint)
                               as *mut RCC_TypeDef)).CFGR &
                            0xf0i32 as uint32_t) >> 4i32) as usize] as
            uint32_t;
    /* HCLK clock frequency */
    SystemCoreClock >>= tmp;
}
/* *
  * @}
  */
/* * @addtogroup STM32F30x_System_Private_FunctionPrototypes
  * @{
  */
/* *
  * @brief  Configures the System clock source, PLL Multiplier and Divider factors,
  *               AHB/APBx prescalers and Flash settings
  * @note   This function should be called only once the RCC clock configuration
  *         is reset to the default reset state (done in SystemInit() function).
  * @param  None
  * @retval None
  */
#[no_mangle]
pub unsafe extern "C" fn SetSysClock() {
    let mut StartUpCounter: uint32_t = 0i32 as uint32_t;
    let mut HSEStatus: uint32_t = 0i32 as uint32_t;
    /* *****************************************************************************/
/*            PLL (clocked by HSE) used as System clock source                */
/* *****************************************************************************/
    /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration -----------*/
  /* Enable HSE */
    let ref mut fresh7 =
        (*((0x40000000i32 as
                uint32_t).wrapping_add(0x20000i32 as
                                           libc::c_uint).wrapping_add(0x1000i32
                                                                          as
                                                                          libc::c_uint)
               as *mut RCC_TypeDef)).CR;
    ::core::ptr::write_volatile(fresh7,
                                (::core::ptr::read_volatile::<uint32_t>(fresh7
                                                                            as
                                                                            *const uint32_t)
                                     as libc::c_uint | 0x10000i32 as uint32_t)
                                    as uint32_t as uint32_t);
    loop 
         /* Wait till HSE is ready and if Time out is reached exit */
         {
        ::core::ptr::write_volatile(&mut HSEStatus as *mut uint32_t,
                                    (*((0x40000000i32 as
                                            uint32_t).wrapping_add(0x20000i32
                                                                       as
                                                                       libc::c_uint).wrapping_add(0x1000i32
                                                                                                      as
                                                                                                      libc::c_uint)
                                           as *mut RCC_TypeDef)).CR &
                                        0x20000i32 as uint32_t);
        ::core::ptr::write_volatile(&mut StartUpCounter as *mut uint32_t,
                                    ::core::ptr::read_volatile::<uint32_t>(&StartUpCounter
                                                                               as
                                                                               *const uint32_t).wrapping_add(1));
        if !(HSEStatus == 0i32 as libc::c_uint &&
                 StartUpCounter != 0x5000i32 as uint16_t as libc::c_uint) {
            break ;
        }
    }
    if (*((0x40000000i32 as
               uint32_t).wrapping_add(0x20000i32 as
                                          libc::c_uint).wrapping_add(0x1000i32
                                                                         as
                                                                         libc::c_uint)
              as *mut RCC_TypeDef)).CR & 0x20000i32 as uint32_t !=
           RESET as libc::c_int as libc::c_uint {
        ::core::ptr::write_volatile(&mut HSEStatus as *mut uint32_t,
                                    0x1i32 as uint32_t)
    } else {
        ::core::ptr::write_volatile(&mut HSEStatus as *mut uint32_t,
                                    0i32 as uint32_t)
    }
    if HSEStatus == 0x1i32 as uint32_t {
        /* Enable Prefetch Buffer and set Flash Latency */
        ::core::ptr::write_volatile(&mut (*((0x40000000i32 as
                                                 uint32_t).wrapping_add(0x20000i32
                                                                            as
                                                                            libc::c_uint).wrapping_add(0x2000i32
                                                                                                           as
                                                                                                           libc::c_uint)
                                                as *mut FLASH_TypeDef)).ACR as
                                        *mut uint32_t,
                                    0x10i32 as uint8_t as libc::c_uint |
                                        0x2i32 as uint8_t as uint32_t);
        /* HCLK = SYSCLK / 1 */
        let ref mut fresh8 =
            (*((0x40000000i32 as
                    uint32_t).wrapping_add(0x20000i32 as
                                               libc::c_uint).wrapping_add(0x1000i32
                                                                              as
                                                                              libc::c_uint)
                   as *mut RCC_TypeDef)).CFGR;
        ::core::ptr::write_volatile(fresh8,
                                    (::core::ptr::read_volatile::<uint32_t>(fresh8
                                                                                as
                                                                                *const uint32_t)
                                         as libc::c_uint | 0i32 as uint32_t)
                                        as uint32_t as uint32_t);
        /* PCLK2 = HCLK / 1 */
        let ref mut fresh9 =
            (*((0x40000000i32 as
                    uint32_t).wrapping_add(0x20000i32 as
                                               libc::c_uint).wrapping_add(0x1000i32
                                                                              as
                                                                              libc::c_uint)
                   as *mut RCC_TypeDef)).CFGR;
        ::core::ptr::write_volatile(fresh9,
                                    (::core::ptr::read_volatile::<uint32_t>(fresh9
                                                                                as
                                                                                *const uint32_t)
                                         as libc::c_uint | 0i32 as uint32_t)
                                        as uint32_t as uint32_t);
        /* PCLK1 = HCLK / 2 */
        let ref mut fresh10 =
            (*((0x40000000i32 as
                    uint32_t).wrapping_add(0x20000i32 as
                                               libc::c_uint).wrapping_add(0x1000i32
                                                                              as
                                                                              libc::c_uint)
                   as *mut RCC_TypeDef)).CFGR;
        ::core::ptr::write_volatile(fresh10,
                                    (::core::ptr::read_volatile::<uint32_t>(fresh10
                                                                                as
                                                                                *const uint32_t)
                                         as libc::c_uint |
                                         0x400i32 as uint32_t) as uint32_t as
                                        uint32_t);
        /* PLL configuration */
        let ref mut fresh11 =
            (*((0x40000000i32 as
                    uint32_t).wrapping_add(0x20000i32 as
                                               libc::c_uint).wrapping_add(0x1000i32
                                                                              as
                                                                              libc::c_uint)
                   as *mut RCC_TypeDef)).CFGR;
        ::core::ptr::write_volatile(fresh11,
                                    (::core::ptr::read_volatile::<uint32_t>(fresh11
                                                                                as
                                                                                *const uint32_t)
                                         as libc::c_uint &
                                         !(0x10000i32 as uint32_t |
                                               0x20000i32 as uint32_t |
                                               0x3c0000i32 as uint32_t)) as
                                        uint32_t as uint32_t);
        if 8000000i32 == 12000000i32 {
            let ref mut fresh12 =
                (*((0x40000000i32 as
                        uint32_t).wrapping_add(0x20000i32 as
                                                   libc::c_uint).wrapping_add(0x1000i32
                                                                                  as
                                                                                  libc::c_uint)
                       as *mut RCC_TypeDef)).CFGR;
            ::core::ptr::write_volatile(fresh12,
                                        (::core::ptr::read_volatile::<uint32_t>(fresh12
                                                                                    as
                                                                                    *const uint32_t)
                                             as libc::c_uint |
                                             (0x10000i32 as uint32_t |
                                                  0i32 as uint32_t |
                                                  0x100000i32 as uint32_t)) as
                                            uint32_t as uint32_t)
        } else {
            let ref mut fresh13 =
                (*((0x40000000i32 as
                        uint32_t).wrapping_add(0x20000i32 as
                                                   libc::c_uint).wrapping_add(0x1000i32
                                                                                  as
                                                                                  libc::c_uint)
                       as *mut RCC_TypeDef)).CFGR;
            ::core::ptr::write_volatile(fresh13,
                                        (::core::ptr::read_volatile::<uint32_t>(fresh13
                                                                                    as
                                                                                    *const uint32_t)
                                             as libc::c_uint |
                                             (0x10000i32 as uint32_t |
                                                  0i32 as uint32_t |
                                                  0x1c0000i32 as uint32_t)) as
                                            uint32_t as uint32_t)
        }
        /* Enable PLL */
        let ref mut fresh14 =
            (*((0x40000000i32 as
                    uint32_t).wrapping_add(0x20000i32 as
                                               libc::c_uint).wrapping_add(0x1000i32
                                                                              as
                                                                              libc::c_uint)
                   as *mut RCC_TypeDef)).CR;
        ::core::ptr::write_volatile(fresh14,
                                    (::core::ptr::read_volatile::<uint32_t>(fresh14
                                                                                as
                                                                                *const uint32_t)
                                         as libc::c_uint |
                                         0x1000000i32 as uint32_t) as uint32_t
                                        as uint32_t);
        /* Wait till PLL is ready */
        while (*((0x40000000i32 as
                      uint32_t).wrapping_add(0x20000i32 as
                                                 libc::c_uint).wrapping_add(0x1000i32
                                                                                as
                                                                                libc::c_uint)
                     as *mut RCC_TypeDef)).CR & 0x2000000i32 as uint32_t ==
                  0i32 as libc::c_uint {
        }
        /* Select PLL as system clock source */
        let ref mut fresh15 =
            (*((0x40000000i32 as
                    uint32_t).wrapping_add(0x20000i32 as
                                               libc::c_uint).wrapping_add(0x1000i32
                                                                              as
                                                                              libc::c_uint)
                   as *mut RCC_TypeDef)).CFGR;
        ::core::ptr::write_volatile(fresh15,
                                    (::core::ptr::read_volatile::<uint32_t>(fresh15
                                                                                as
                                                                                *const uint32_t)
                                         as libc::c_uint &
                                         !(0x3i32 as uint32_t)) as uint32_t as
                                        uint32_t);
        let ref mut fresh16 =
            (*((0x40000000i32 as
                    uint32_t).wrapping_add(0x20000i32 as
                                               libc::c_uint).wrapping_add(0x1000i32
                                                                              as
                                                                              libc::c_uint)
                   as *mut RCC_TypeDef)).CFGR;
        ::core::ptr::write_volatile(fresh16,
                                    (::core::ptr::read_volatile::<uint32_t>(fresh16
                                                                                as
                                                                                *const uint32_t)
                                         as libc::c_uint | 0x2i32 as uint32_t)
                                        as uint32_t as uint32_t);
        /* Wait till PLL is used as system clock source */
        while (*((0x40000000i32 as
                      uint32_t).wrapping_add(0x20000i32 as
                                                 libc::c_uint).wrapping_add(0x1000i32
                                                                                as
                                                                                libc::c_uint)
                     as *mut RCC_TypeDef)).CFGR & 0xci32 as uint32_t !=
                  0x8i32 as uint32_t {
        }
    };
}
/* *********************** (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
/* *
  * @}
  */
/* *
  * @}
  */
/* *
  * @}
  */
